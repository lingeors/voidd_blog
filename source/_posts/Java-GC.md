---
title: Java 垃圾回收
date: 2017-07-06 13:24:15
tags:
    - Java
    - Java-GC
---

> 在C语言时代，内存怎么分配，堆栈分别用来存储什么都是需要程序员了解的，因为内存分配不当或者指针问题导致进程死掉应该也是常事。而Java的内存管理机制正是为了解决这个问题，其中，垃圾回收是其中重要的部分。本文主要介绍 Java垃圾回收的相关理论基础和算法

<!-- more -->

## 前言
在如 C/C++ 这些相对比较底层的语言中，对象所需内存的申请以及释放需要程序员自己控制，稍不注意，很容易造成内存泄漏，而在如 Java、Python、PHP 等大部分语言中，内存管理都被移到了语言之后，由语言本身进行管理。通常情况下，这种内存管理方式更加高效，因内存产生的问题更少，我们也可以更加专注于业务本身
这里我们主要介绍 Java 内存管理的 “垃圾回收(GC)” 机制的相关原理。
在 [深入理解Java虚拟机][1] 中，作者提到 GC 需要完成的三件事：1. 哪些内存需要回收；2. 什么时候回收；3. 如何回收
本文主要介绍第一点和第三点。
对于第一点，可以进一步转化为 “如何判断哪些内存需要回收”，本文提到的方法有两种，分别为：
1. 引用计数
2. 可达性分析

对于第三点，主要考虑的是通过权衡效率和空间问题来选择合适的策略释放“垃圾内存”并重新整理内存空间，本文提到的主要内容有：
1. 标记-清除算法
2. 复制算法
3. 标记-整理算法
4. 分代收集算法


## 哪些对象需要回收
所谓的“垃圾”，实际上就是不再被使用的对象，因此“垃圾回收”也是“不可用对象”所占内存的释放。在Java中，程序计数器，虚拟机栈以及本地方法栈的内存空间随线程而生，随线程而死，它们并不属于GC的管理范畴。而在 Java 堆以及方法区中，对象所占的空间是在运行期间确定的，它们的内存分配和回收是动态的，这部分正是 GC 所关注的。

### 引用计数
引用技术是用来判断对象是否需要被回收的一种方法。该算法是Python，PHP等语言进行垃圾对象判断的基础。这种方式相对来说比较简单。如下图对象 
![](/images/Java-GC/ref-count-1.png)
引用计数通过一个 ref_count 字段记录当前对象被引用的次数，当引用次数为0时，说明该对象可以被回收。这种方法简单并且效率很高。但是当存在对象循环引用时，如果没有其他措施，则涉及到的对象将永远不会被释放。

### 可达性分析
Java 采用一种称为 “可达性分析” 的方式来判断对象是否存活。如下图所示
![](/images/Java-GC/reachability_analysis_1.png)
这种方式将对象组织成树的形式，其中分界线以下的节点为我们需要进行处理的对象，分界线上的对象我们称之为 “GCRoots”，节点间的连线称为 “引用链”。**当一个对象可以通过 “GCRoots” 对象访问到时，表示该对象是“存活的”**，否则该对象是“死亡的”，其所占内存需要被回收。因此，上图中以 a 为根节点的树中的所有对象将不会被回收，而其它都是需要被回收的对象。（b，c及其所有子节点）

在 Java 中，GCRoots 可以为以下对象：
- 虚拟机栈中引用的对象
- 本地方法栈用 JNI 中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象

在引用计数中，我们是通过 ref_count 直接找出死亡的对象，而在可达性分析中，**是通过找出存活的对象间接找出死亡的对象**。通过遍历所有 GCRoots 为根的树，可以很容易找出所有的存活对象，这点很容易理解，问题的关键在于 GCRoots 究竟是什么？通过上述可作为 GCRoots 的对象类型，我们可以发现，GCRoots对象 是不受 GC 控制的，因此对于 GC 而言，它可以查找到的 GCRoots 对象是 “永远存活的”。因此事情变得更加简单：GC之外负责管理 GCRoots 对象，GC通过遍历 GCRoots集合判断对象存活状态。


## 垃圾回收算法
垃圾回收算法有很多种，我们可以根据具体内存空间以及对象状态的特点选择合适的垃圾回收算法

### 标记-清除算法
标记-清除算法比较简单，它通过 “引用计数” 或者 “可达性分析” 找出待回收对象后，将他们进行标记，标记完成后再统一回收被标记的对象。如下图所示：
![](/images/Java-GC/mark-sweep-1.png)
该算法存在空间和效率问题，空间问题：该算法在执行清除步骤后，存在空间碎片；效率问题：标记和清除过程都需要遍历所有对象

### 复制算法
复制算法将内存空间分成两部分，任意时刻只有一部分空间可用。在进行一次回收时，GC会将存活的对象复制到另一空间，如下图所示：
![](/images/Java-GC/copying-1.png)
复制算法解决了空间碎片的问题，但却造成了空间的浪费。另一方面，它也避免了 “标记-清除” 算法中需要两次遍历对象带来的效率较低的问题。

Java虚拟机在应用 “复制算法” 是，将所用的内存分为三个部分，其中较大的部分称为 **Eden空间**，较小的部分又分为两部分，称为 **Survivor空间**。任意时间，只用到了Eden空间以及一块 Survivor空间。如下图所示
![](/images/Java-GC/copying-2.png)
在清除前，我们用到了Eden空间以及Survivor-1空间，Survivor-2空间空闲，GC清除过程中，将上述两个空间中存活的对象复制到 Survivor-2空间，并清除 Eden和Survivor-1空间，接下来的对象将被存储到 Eden和Survivor-2空间，Survivor-1空间空闲。通过这种方式，复制算法在任意时间只浪费了一块 Survivor空间的内存。在 HotSpot 的默认实现中，Survivor占新生代空间的10%（新生代指使用复制算法的内存空间）

### 标记-整理算法
标记整理算法很简单，先标记当前存活对象，再将存活的对象按序复制到内存的一端，然后清除范围外的内存空间。如下图所示
![](/images/Java-GC/mark-coping-1.png)
该算法解决了 “标记-清除算法” 产生空间碎片的问题

### 分代回收算法
Java根据当前对象存活周期的不同将堆内存分为两部分，分别称为“新生代”和“老年代”，一个对象处于哪个内存部分一般是通过该对象经历过多少次GC来判断的。“新生代”用来存放存周期较短的对象，一般情况下，在每次GC中，这些对象大部分都将被回收，存活的对象很少，因此采用的是 “复制算法”；“老年代” 用来存放生存周期较长的对象，比如经历了多次GC仍然存活的对象，一般而言，这些对象在一次GC中被回收的概率较小，采用的是 “标记-清除算法” 或 “标记-整理算法”

## 总结
1. Java通过 “可达性分析” 来找出存活的对象
2. Java将堆内存分为“新生代”和“老年代”，“新生代”一般使用“复制算法”，“老年代”一般使用“标记-清除算法”或“标记-整理算法”

## 参考
[深入理解Java虚拟机][1]
[Java的GC为什么要分代？ - RednaxelaFX 的回答 - 知乎][2]


[1]: https://book.douban.com/subject/24722612/
[2]: https://www.zhihu.com/question/53613423/answer/135743258