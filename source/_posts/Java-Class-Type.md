---
title: Java多态相关原理
date: 2017-06-13 21:30:37
tags:
    - Java
    - 多态
    - RTTI
    - 多态机制
---
> 多态在不同语言有不同的解释与具体实现。而Java多态是比较常见且强大的。这里我们先介绍 Java多态的使用以及带来的效果，接着介绍 Java多态实现的基础，即类型信息的表示与实现。

<!-- more -->

## 前言
这篇文章主要介绍下面两点：
- 什么是多态
- 多态是怎么获取对象的类型信息的

## 多态
理解多态，个人觉得最简单、最快捷的方式就是看相关的例子，如下
```java
// Shape.java
package top.voidd.www;

public interface Shape {
    void draw() ;
}
// Circle.java
package top.voidd.www;

public class Circle implements Shape {
    public void draw() {
        System.out.println("画一个圆");
    }
}
// Rectangle.java
package top.voidd.www;

public class Rectangle implements Shape {
    public void draw() {
        System.out.println("画一个矩形");
    }
}
// Client.java
package top.voidd.www;

public class Client {
    public static void main(String[] args) {
        Shape shape = new Circle();
        shape.draw();
    }
    public static test(Shape shape) {
        shape.draw();
    }
}
// 运行结果
画一个圆
```
这里我们定义了一个基类 `Shape`，以及两个子类 `Circle, Rectangle`。
现在重点关注客户端代码 `Client.java`。第 29 行 `shape.draw()`，其中 shape 是 `Shape` 类型，我们调用了它的 `draw` 方法，**而运行结果显示的是 `Circle` 对象的执行结果**。如果只关注这里，我们很容易发现一点，客户端代码大部分时候不涉及具体的对象类型，它们不知道，也不关心，这样带来的好处也很明显，当我们要使用 Shape 的另一个实现 Rectangle 时，只需要改 28 行这一行代码即可。（同样对于 Client 的 test 方法，我们的参数类型使用了 Shape，如果使用具体类型，则我们有多少个具体类型就需要多少个重载方法）

现在，让我们先忽略“多态”的定义，从作用来说，多态就是一种能让你用 **基类型引用(Shape)** 来调用 **子类型实现(Circle或Rectangle)** 的机制，换句话说，**同样的代码** `shape.draw()`， 当 `Shape shape = new Circle()` 改变时，执行的效果是不一样的，再换句话说，**同样的代码，执行后可以有多种不同的状态体现。**而最后面这句，也就是我个人对多态的理解和定义。
 
多态是语言的一种内置机制，上面介绍的是大多数情况下的多态概念，一般而言，它是针对强类型语言的，如php等弱类型语言同样有多态的机制，但概念却可能是完全不同，这点需要稍加注意。

实际上，多态就是这么简单。而多态的神奇之处，在于它给编程带来的效果。我们知道，面向对象编程有几大原则，其中 “开闭原则”，“里氏代换原则”，“依赖倒置原则” 等都以多态为基础。这里我们以 “开闭原则” 为例子。
“开闭原则” 要求 “对扩展开放，对修改关闭”。以上面的 `Shape` 类为例，当我们要增加一个新的 `Shape` 实现时，只能通过增减新代码的方式，而不能修改原有的代码。具体实现如下：
1. 添加新的 Shape 实现 Ellipse.java
2. 修改 Client.java, 第28行改为 `Shape shape = new Ellipse()` 

如果我们再添加额外的条件：shape 被系统多个类引用。此时就比较明晰了，**我们只修改了一行代码，就改变了系统多个部分的具体行为**（`shape.draw()`）。（当然，我们这里还是改变了客户端的一小部分代码，但如果我们通过配置文件来引入具体类，则实际上只需要添加新的实现，然后修改配置文件。完全符合开闭原则。）

## 类型信息
从前面可以看到，通过多态机制 shape 可以自动识别具体的类型（如 Circle），并产生正确的行为（调用 Circle 的 draw），现在我们要讨论的就是它是如何获取正确的类型信息的。

首先，我们先了解几个概念
1. 向上转型：把对某个对象的引用视为对其基类型的引用的做法。具体到上面的例子，也就是对 `Circle或Rectangle` 对象的引用 shape 被视作 Shape 类型的引用。
2. 绑定：将一个方法调用同一个方法主体关联起来。前面方法调用为 draw，方法主体为 Circle。
3. 前期绑定：在程序执行前进行绑定，即Java中的编译阶段实现。具体来说，就是在程序运行前，draw 的主体是 Cricle 还是 Rectangle 是确定的
4. 后期绑定：在 **运行时** 根据对象的类型进行绑定。具体来说，就是只有在程序执行的时候，才能确定 draw 是 Circle 的行为还是 Rectangle 的行为。具备后期绑定特性的语言，**必定有某种机制可以让对象引用在运行时获得具体的对象类型信息**。Java 多态就是一种依赖后期绑定的机制

### RTTI
RTTI: *Runtime Type Identification* 运行时类型信息

Java 多态能在程序执行时找到正确的类型信息，靠的就是 RTTI。关于这个名词的理解，我分为两部分：1. 这些信息是程序运行时的信息。2. 这些信息是对象类型信息。 
RTTI 也分两种，一种是编译时就知道了对象引用的具体类型，一种是通过反射机制，在运行时发现和使用类的信息，显然，我们只关心后者。再具体一点，我们需要关心的是 **RTTI 在内存中的表示**，了解了具体表示，问题也就基本解决了

### Class 对象
当我们通过 `javac` 编译 java 源码时，每个类会生成一个 `.class` 文件，这个文存储了对应类的所有信息，如果读者对网络协议有所了解，可以类比 tcp 协议，如前两个字节表示源端口号，后面字节表示其他具体含义等。`.class` 文件也是如此，每一个字节表示什么，都是协议规范好的，遵循该协议编写的 JVM 可以读取并解析该文件，而解析出来的信息在 JVM 中（或者说内存）是以一个特殊的 `Class对象` 来表示的。这个 Class对象，就是前面的 RTTI 在内存的表示，也就是说，它存储了对应类的全部信息。

当我们加载一个类时，内存中会生成一个 `java.lang.Class` 对象来代表这个类，接下来我们生成的所有对象都以这个特殊的对象为模板来生成。此时可以说，运行时对象引用的具体类型信息的数据来源为对应的 Class对象。

## 具体过程
我们再来理一下思路，对于 `Shape shape = new Circle(); shape.draw();`，我们通过向上转型的方式将具体类型（Circle）对象的引用用 Shape 类型来定义，在编译阶段，编译器只知道 shape 是 Shape 类型，也就说，此时它遗失了 shape 的具体类型信息。而在运行时，我们执行 draw 是需要确定 shape 的具体类型的，否则无法产生正确的行为，此时我们说我们需要知道 shape 的 RTTI，而 RTTI 在计算机中表示为特殊的 `java.lang.Class`对象，在通过反射机制，它的所有类型信息都可从该对象获取。
由此通过后期绑定实现了多态机制。

## 总结
1. 多态是一种很棒的机制，它是我们的程序能否满足面向对象基本原则的关键部分，合理应用多态可以有效提高我们代码的可扩展性和可维护性
2. 多态是基于后期绑定的，即编译器是不知道对象引用的实际类型，而是在编译时通过RTTI来获取对象的具体类型信息的。
3. RTTI 在内存中表示为 `java.lang.Class对象`，通过反射机制我们可以从该 Class对象 获取和使用类的信息

## 参考
[Java编程思想 （第4版）][1]
[Java核心技术·卷1][2]


[1]: https://book.douban.com/subject/2130190/
[2]: https://book.douban.com/subject/25762168/